"""2D-to-3D Task -- Rhino 3D Modeling from Engineering Drawings.

The agent is given a 2D engineering drawing (PDF) of a mechanical workpiece
and must build the corresponding 3D model in Rhinoceros (Rhino), then export
it as a STEP file. Evaluation compares geometric features of the agent's
output against a pre-extracted ground truth.

Variants: Multiple workpieces with identical evaluation logic but different geometry.
"""

import asyncio
import json
import logging
import os
from dataclasses import dataclass
from pathlib import Path

import cua_bench as cb
from tasks.common_config import GeneralTaskConfig

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# All 129 workpiece variants (3 groups)
# Each tuple: (task_tag, display_name)
# Generated by organize_data.py from raw data on remote VM
# ---------------------------------------------------------------------------
VARIANTS = [
    # SMA线寿命测试电阻焊夹具 (8 pairs)
    ("32300A_000001", "32300A-000001"),
    ("32300A_000002", "32300A-000002"),
    ("32300A_000003", "32300A-000003"),
    ("32300A_000004", "32300A-000004"),
    ("32300A_000005", "32300A-000005"),
    ("32300A_000006", "32300A-000006"),
    ("32300A_000007", "32300A-000007"),
    ("32300A_000008", "32300A-000008"),
    # 半自动电阻焊机 (121 pairs)
    ("20630A_000001", "20630A-000001"),
    ("20630A_000002", "20630A-000002"),
    ("20630A_000004", "20630A-000004"),
    ("20630A_000005", "20630A-000005"),
    ("20630A_000006", "20630A-000006"),
    ("20630A_000007", "20630A-000007"),
    ("20630A_100001", "20630A-100001"),
    ("20630A_300001", "20630A-300001"),
    ("20630A_400008", "20630A-400008"),
    ("20630A_400009", "20630A-400009"),
    ("20630A_500001", "20630A-500001"),
    ("20630A_500002", "20630A-500002"),
    ("20630A_500003", "20630A-500003"),
    ("20630A_500004", "20630A-500004"),
    ("20630A_500005", "20630A-500005"),
    ("20630A_500006", "20630A-500006"),
    ("20630A_500007", "20630A-500007"),
    ("20630A_500008", "20630A-500008"),
    ("20630A_500009", "20630A-500009"),
    ("20630A_500010", "20630A-500010"),
    ("20630A_500011", "20630A-500011"),
    ("20630A_500012", "20630A-500012"),
    ("20630A_500013", "20630A-500013"),
    ("20630A_700001", "20630A-700001"),
    ("20630A_700002", "20630A-700002"),
    ("20630A_700003", "20630A-700003"),
    ("20630A_700004", "20630A-700004"),
    ("20630A_700005", "20630A-700005"),
    ("20630A_700012", "20630A-700012"),
    ("20630A_700013", "20630A-700013"),
    ("20630A_700014", "20630A-700014"),
    ("20630A_700015", "20630A-700015"),
    ("20630A_700016", "20630A-700016"),
    ("20630A_700018", "20630A-700018"),
    ("20630A_700019", "20630A-700019"),
    ("20630A_700020", "20630A-700020"),
    ("20630A_700021", "20630A-700021"),
    ("20630A_700022", "20630A-700022"),
    ("20630A_700023", "20630A-700023"),
    ("20630A_700024", "20630A-700024"),
    ("20630A_700025", "20630A-700025"),
    ("20630A_700026", "20630A-700026"),
    ("20630B_110001", "20630B-110001"),
    ("20630B_110002", "20630B-110002"),
    ("20630B_110003", "20630B-110003"),
    ("20630B_111001", "20630B-111001"),
    ("20630B_111002", "20630B-111002"),
    ("20630B_111003", "20630B-111003"),
    ("20630B_111004", "20630B-111004"),
    ("20630B_111005", "20630B-111005"),
    ("20630B_111006", "20630B-111006"),
    ("20630B_112001", "20630B-112001"),
    ("20630B_112002", "20630B-112002"),
    ("20630B_112003", "20630B-112003"),
    ("20630B_112004", "20630B-112004"),
    ("20630B_112005", "20630B-112005"),
    ("20630B_112006", "20630B-112006"),
    ("20630B_112007", "20630B-112007"),
    ("20630B_112009", "20630B-112009"),
    ("20630B_112010", "20630B-112010"),
    ("20630B_112011", "20630B-112011"),
    ("20630B_112012", "20630B-112012"),
    ("20630B_112014", "20630B-112014"),
    ("20630B_112015", "20630B-112015"),
    ("20630B_112016", "20630B-112016"),
    ("20630B_120001", "20630B-120001"),
    ("20630B_120002", "20630B-120002"),
    ("20630B_120004", "20630B-120004"),
    ("20630B_120006", "20630B-120006"),
    ("20630B_120007", "20630B-120007"),
    ("20630B_120008", "20630B-120008"),
    ("20630B_120009", "20630B-120009"),
    ("20630B_120010", "20630B-120010"),
    ("20630B_120014", "20630B-120014"),
    ("20630B_120015", "20630B-120015"),
    ("20630B_121001", "20630B-121001"),
    ("20630B_130001", "20630B-130001"),
    ("20630B_130002", "20630B-130002"),
    ("20630B_130003", "20630B-130003"),
    ("20630B_130004", "20630B-130004"),
    ("20630B_130005", "20630B-130005"),
    ("20630B_130006", "20630B-130006"),
    ("20630B_140001", "20630B-140001"),
    ("20630B_140002", "20630B-140002"),
    ("20630B_140003", "20630B-140003"),
    ("20630B_140004", "20630B-140004"),
    ("20630B_140005", "20630B-140005"),
    ("20630B_140006", "20630B-140006"),
    ("20630B_140007", "20630B-140007"),
    ("20630B_140008", "20630B-140008"),
    ("20630B_140009", "20630B-140009"),
    ("20630B_140010", "20630B-140010"),
    ("20630B_140012", "20630B-140012"),
    ("20630B_140013", "20630B-140013"),
    ("20630B_150001", "20630B-150001"),
    ("20630B_150002", "20630B-150002"),
    ("20630B_150003", "20630B-150003"),
    ("20630B_150004", "20630B-150004"),
    ("20630B_150006", "20630B-150006"),
    ("20630B_150007", "20630B-150007"),
    ("20630B_150008", "20630B-150008"),
    ("20630B_160002", "20630B-160002"),
    ("20630B_160003", "20630B-160003"),
    ("20630B_160004", "20630B-160004"),
    ("20630B_160005", "20630B-160005"),
    ("20630B_160006", "20630B-160006"),
    ("20630B_160008", "20630B-160008"),
    ("20630B_160009", "20630B-160009"),
    ("20630B_160010", "20630B-160010"),
    ("20630B_160011", "20630B-160011"),
    ("20630B_161004", "20630B-161004"),
    ("20630B_161005", "20630B-161005"),
    ("20630B_162001", "20630B-162001"),
    ("20630B_162002", "20630B-162002"),
    ("20630B_162003", "20630B-162003"),
    ("20630B_162004", "20630B-162004"),
    ("20630B_162005", "20630B-162005"),
    ("20630B_162006", "20630B-162006"),
    ("20630B_163001", "20630B-163001"),
    ("20630B_163003", "20630B-163003"),
    ("20630B_170001", "20630B-170001"),
    # 单线马达 Tooling (4 pairs — from 20260208 version)
    # Note: these 4 overlap with SMA group names, but SMA ones were processed first
]


#################################################################
############################# Config ############################
#################################################################


@dataclass
class Dto3DTaskConfig(GeneralTaskConfig):
    """Configuration for a single 2D-to-3D workpiece task."""

    TASK_CATEGORY: str = r"manufacturing\2dto3d"
    TASK_TAG: str = ""

    @property
    def input_dir(self) -> str:
        return rf"{self.task_dir}\input"

    @property
    def input_pdf(self) -> str:
        """The engineering drawing PDF in input/ (read-only)."""
        return rf"{self.input_dir}\{self.TASK_TAG}.pdf"

    @property
    def output_step(self) -> str:
        """The agent's exported STEP file in output/."""
        return rf"{self.remote_output_dir}\{self.TASK_TAG}.step"

    @property
    def reference_step(self) -> str:
        """Ground truth .step file."""
        return rf"{self.reference_dir}\{self.TASK_TAG}.step"

    @property
    def reference_json(self) -> str:
        """Pre-extracted ground truth features JSON."""
        return rf"{self.reference_dir}\gt_features.json"

    @property
    def task_description(self) -> str:
        return f"""\
You are a CAD (Computer-Aided Design) engineer using Rhinoceros 3D (Rhino).

## Your Task
Build a 3D solid model of workpiece **{self.TASK_TAG}** by reading a 2D engineering drawing.

## Input Files
- **Engineering drawing** (PDF with dimensions and multi-view projections):
  `{self.input_pdf}`
  (This PDF has been copied to your output folder for reference.)

## What You Must Do
1. Open the engineering drawing PDF to study the workpiece dimensions and geometry
2. Open Rhino (shortcut in `{self.software_dir}`)
3. Build the 3D solid model in Rhino based on the engineering drawing:
   - Read all dimensions carefully from the drawing
   - Create the base shape using the main view
   - Add features (holes, slots, chamfers, fillets) according to the drawing
   - Ensure all dimensions match the drawing precisely
4. Export the completed model as a STEP file:
   - File > Export Selected > Save as type: STEP (*.stp, *.step)
   - Save to: `{self.output_step}`
5. Save the Rhino project as well

## Engineering Drawing Reading Guide
- The PDF contains multiple orthographic views (front, top, side)
- Dimensions are in millimeters (mm)
- Circles with center marks indicate holes (through or blind)
- Dashed/hidden lines indicate features behind the visible surface
- Section views (marked A-A, B-B, etc.) show internal structure

## Evaluation
Your 3D model will be automatically evaluated by comparing:
1. Volume and bounding box accuracy (20%)
2. Feature count correctness — number of holes per diameter (30%)
3. Feature position and axis accuracy (50%)

## Important
- Export MUST be in STEP format (.step or .stp)
- Save the file to: `{self.output_step}`
- Dimensions must match the engineering drawing precisely
"""

    def to_metadata(self) -> dict:
        metadata = super().to_metadata()
        metadata.update(
            {
                "input_pdf": self.input_pdf,
                "output_step": self.output_step,
                "reference_step": self.reference_step,
                "reference_json": self.reference_json,
            }
        )
        return metadata


# ---------------------------------------------------------------------------
# Local scripts directory — scripts are read from here and uploaded to VM
# as temporary files during evaluation.
# ---------------------------------------------------------------------------
SCRIPTS_DIR = Path(__file__).parent / "scripts"


def _read_script(name: str) -> str:
    """Read a script file from the local scripts/ directory."""
    return (SCRIPTS_DIR / name).read_text(encoding="utf-8")


#################################################################
###################### Task Registration ########################
#################################################################


@cb.tasks_config(split="train")
def load():
    """Register all 2D-to-3D task variants."""
    return [
        cb.Task(
            description=Dto3DTaskConfig(
                TASK_TAG=tag,
            ).task_description,
            metadata=Dto3DTaskConfig(
                TASK_TAG=tag,
            ).to_metadata(),
            computer={
                "provider": "computer",
                "setup_config": {"os_type": "windows"},
            },
        )
        for tag, _ in VARIANTS
    ]


#################################################################
######################## Initialization #########################
#################################################################


@cb.setup_task(split="train")
async def start(task_cfg, session: cb.DesktopSession):
    """Prepare the environment before the agent starts.

    Steps:
    1. Clean and recreate the output directory
    2. Copy the engineering drawing PDF from input/ to output/
    3. Open the PDF so the agent can see the drawing
    """
    meta = task_cfg.metadata
    task_tag = meta["task_tag"]
    output_dir = meta["remote_output_dir"]
    input_pdf = meta["input_pdf"]

    logger.info(f"[{task_tag}] Setting up 2D-to-3D task")

    # 1. Clean and recreate output directory
    try:
        await session.remove_file(output_dir)
    except Exception:
        pass
    await session.makedirs(output_dir)
    logger.info(f"[{task_tag}] Output directory ready: {output_dir}")

    # 2. Copy PDF to output so agent has a working copy
    pdf_basename = os.path.basename(input_pdf)
    output_pdf = rf"{output_dir}\{pdf_basename}"
    await session.copy_file(input_pdf, output_pdf)
    logger.info(f"[{task_tag}] Copied PDF to output: {output_pdf}")

    # 3. Open the PDF for the agent to view
    try:
        await session.run_file(output_pdf)
        logger.info(f"[{task_tag}] Opened PDF: {output_pdf}")
    except Exception as e:
        logger.warning(f"[{task_tag}] Could not auto-open PDF: {e}")

    # Give the PDF viewer time to load
    await asyncio.sleep(5)
    logger.info(f"[{task_tag}] Setup complete — agent may begin")


#################################################################
########################## Evaluation ###########################
#################################################################


@cb.evaluate_task(split="train")
async def evaluate(task_cfg, session: cb.DesktopSession) -> list[float]:
    """Score the agent's 3D model.

    Pipeline (full run):
      1. Upload evaluation scripts to a temp location on the VM
      2. Gate check: verify output STEP file exists and is loadable
      3. Extract features from agent's STEP file → agent_features.json
      4. Compare agent_features.json vs gt_features.json → score

    Test mode:
      If agent_features.json already exists in the output directory (e.g.,
      placed by setup_test_dirs.py for pos/neg testing), step 3 is skipped
      and only the comparison (step 4) runs.
    """
    meta = task_cfg.metadata
    task_tag = meta["task_tag"]
    output_dir = meta["remote_output_dir"]
    output_step = meta["output_step"]
    ref_json = meta["reference_json"]

    logger.info(f"[{task_tag}] Starting evaluation (output_dir={output_dir})")

    # ── 0. Upload evaluation scripts to VM temp folder ───────────────────────
    tmp_scripts = r"C:\Users\User\AppData\Local\Temp\2dto3d_eval_scripts"
    await session.makedirs(tmp_scripts)

    for script_name in ["extract_features.py", "verify_3d.py"]:
        script_content = _read_script(script_name)
        remote_path = rf"{tmp_scripts}\{script_name}"
        await session.write_file(remote_path, script_content)

    logger.info(f"[{task_tag}] Evaluation scripts uploaded to {tmp_scripts}")

    # ── Check if agent_features.json already exists (test mode) ──────────────
    agent_features_json = rf"{output_dir}\agent_features.json"
    features_exist = await session.exists(agent_features_json)

    if not features_exist:
        # Full evaluation: gate check + feature extraction + scoring

        # ── 1. Gate: Check output STEP file exists ───────────────────────────
        logger.info(f"[{task_tag}] Step 1/3: Checking output STEP file...")
        if not await session.exists(output_step):
            logger.error(f"[{task_tag}] Output STEP file not found: {output_step}")
            return [0.0]

        # ── 2. Extract features from agent's STEP file ───────────────────────
        logger.info(f"[{task_tag}] Step 2/3: Extracting features from agent STEP...")
        extract_script = rf"{tmp_scripts}\extract_features.py"
        result = await session.run_command(
            f'python "{extract_script}" --file "{output_step}" --output "{agent_features_json}"',
        )
        logger.info(f"[{task_tag}] Extraction: {result.get('stdout', '')[:200]}")

        if result.get("return_code", 1) != 0:
            logger.error(
                f"[{task_tag}] Feature extraction failed: {result.get('stderr', '')[:200]}"
            )
            return [0.0]

        # Verify features JSON was created
        if not await session.exists(agent_features_json):
            logger.error(f"[{task_tag}] agent_features.json not found")
            return [0.0]
    else:
        logger.info(
            f"[{task_tag}] agent_features.json already exists — "
            f"skipping extraction (test mode)"
        )

    # ── 3. Score: compare agent features vs GT features ──────────────────────
    logger.info(f"[{task_tag}] Scoring: Comparing agent features to ground truth...")

    if not await session.exists(ref_json):
        logger.error(f"[{task_tag}] gt_features.json not found: {ref_json}")
        return [0.0]

    verify_script = rf"{tmp_scripts}\verify_3d.py"
    result = await session.run_command(
        f'python "{verify_script}" --agent "{agent_features_json}" --reference "{ref_json}"',
    )

    score = 0.0
    try:
        verify_data = json.loads(result["stdout"])
        score = float(verify_data.get("score", 0.0))
        logger.info(
            f"[{task_tag}] Score={score:.4f}, "
            f"volume_error={verify_data.get('volume_error_ratio', '?')}, "
            f"matched_features={verify_data.get('matched_features', '?')}"
        )
    except Exception as e:
        logger.error(f"[{task_tag}] Could not parse verify output: {e}")

    logger.info(f"[{task_tag}] Final score: {score:.4f}")
    return [score]
